<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Dictation Pad</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Improves touch responsiveness */
        }
        /* Custom styles for the contenteditable div */
        #dictation-box:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        /* Hide scrollbar for the dictation box but allow scrolling */
        #dictation-box::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }
        /* Custom tooltip for context menu buttons */
        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background-color: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 10;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto bg-white rounded-2xl shadow-lg p-4 sm:p-6 flex flex-col h-[90vh]">
        <h1 class="text-2xl sm:text-3xl font-bold text-center mb-4 text-gray-700">Voice Dictation Pad</h1>

        <!-- Controls -->
        <div class="flex flex-wrap items-center justify-center gap-2 mb-4">
            <button id="start-btn" class="flex items-center gap-2 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-all shadow-md">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" x2="12" y1="19" y2="22"></line></svg>
                Start
            </button>
            <button id="stop-btn" class="flex items-center gap-2 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-all shadow-md" disabled>
                 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h12v12H6z"></path></svg>
                Stop
            </button>
            <button id="clear-btn" class="flex items-center gap-2 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition-all shadow-md">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" x2="10" y1="11" y2="17"></line><line x1="14" x2="14" y1="11" y2="17"></line></svg>
                Clear
            </button>
             <button id="undo-btn" class="flex items-center gap-2 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition-all shadow-md">
                 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-2.9-6.7"></path><path d="M21 2v6h-6"></path></svg>
                Undo
            </button>
        </div>
        
        <!-- Status Indicator -->
        <div id="status" class="text-center text-sm text-gray-500 mb-2 h-5 transition-opacity duration-300"></div>

        <!-- Dictation Area -->
        <div id="dictation-box" contenteditable="true" class="flex-grow w-full border-2 border-gray-200 rounded-lg p-4 text-lg leading-relaxed overflow-y-auto bg-gray-50 transition-shadow focus:border-blue-400"></div>
        
        <!-- Saved Entries -->
        <div class="mt-4 flex flex-col sm:flex-row items-center gap-2">
            <select id="entries-dropdown" class="w-full sm:w-auto flex-grow bg-white border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5">
                <option selected>Load a saved entry...</option>
            </select>
            <button id="save-btn" class="w-full sm:w-auto bg-green-500 hover:bg-green-600 text-white font-bold py-2.5 px-5 rounded-lg transition-all shadow-md">
                Save Entry
            </button>
        </div>
    </div>

    <!-- Context Menu (hidden by default) -->
    <div id="context-menu" class="hidden absolute bg-white shadow-xl rounded-lg border border-gray-200 p-1 z-50 flex items-center gap-1">
        <button id="copy-action" class="p-2 rounded hover:bg-gray-100 relative" data-tooltip="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
        <button id="redictate-action" class="p-2 rounded hover:bg-gray-100 relative" data-tooltip="Re-dictate"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" x2="12" y1="19" y2="22"></line></svg></button>
        <button id="delete-action" class="p-2 rounded hover:bg-gray-100 relative" data-tooltip="Delete"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" x2="10" y1="11" y2="17"></line><line x1="14" x2="14" y1="11" y2="17"></line></svg></button>
        <button id="revise-action" class="p-2 rounded hover:bg-gray-100 relative" data-tooltip="Revise"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg></button>
    </div>
    
    <!-- Revise Modal (hidden by default) -->
    <div id="revise-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-lg p-6 shadow-xl w-full max-w-sm">
            <h3 class="text-lg font-medium mb-4">Revise Text</h3>
            <input type="text" id="revise-input" class="w-full border border-gray-300 rounded-md p-2 mb-4 focus:ring-blue-500 focus:border-blue-500">
            <div class="flex justify-end gap-2">
                <button id="cancel-revise" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancel</button>
                <button id="submit-revise" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Revise</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const clearBtn = document.getElementById('clear-btn');
            const undoBtn = document.getElementById('undo-btn');
            const dictationBox = document.getElementById('dictation-box');
            const statusDiv = document.getElementById('status');
            const saveBtn = document.getElementById('save-btn');
            const entriesDropdown = document.getElementById('entries-dropdown');

            const contextMenu = document.getElementById('context-menu');
            const copyAction = document.getElementById('copy-action');
            const redictateAction = document.getElementById('redictate-action');
            const deleteAction = document.getElementById('delete-action');
            const reviseAction = document.getElementById('revise-action');
            
            const reviseModal = document.getElementById('revise-modal');
            const reviseInput = document.getElementById('revise-input');
            const cancelReviseBtn = document.getElementById('cancel-revise');
            const submitReviseBtn = document.getElementById('submit-revise');

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            let recognition;
            
            let isDictating = false;
            let lastContent = '';
            let history = [];
            let lastCursorPosition = null;
            let currentSelectionRange = null;

            if (!SpeechRecognition) {
                statusDiv.textContent = "Sorry, your browser doesn't support the Speech Recognition API.";
                startBtn.disabled = true;
                stopBtn.disabled = true;
                return;
            }

            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            let finalTranscript = '';
            let interimTranscript = '';
            let wasStoppedManually = false;

            // --- State Management ---
            const saveState = () => {
                history.push(dictationBox.innerHTML);
                if (history.length > 20) { // Limit history size
                    history.shift();
                }
                undoBtn.disabled = false;
            };
            
            const recordCaretPosition = () => {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                   lastCursorPosition = selection.getRangeAt(0);
                }
            };
            
            dictationBox.addEventListener('keyup', recordCaretPosition);
            dictationBox.addEventListener('mouseup', recordCaretPosition);
            dictationBox.addEventListener('focus', recordCaretPosition);
            dictationBox.addEventListener('input', () => saveState());

            // --- Speech Recognition Handlers ---
            recognition.onstart = () => {
                isDictating = true;
                wasStoppedManually = false;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                statusDiv.textContent = "Listening...";
                statusDiv.classList.add('opacity-100');
            };

            recognition.onend = () => {
                isDictating = false;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                statusDiv.textContent = "";
                statusDiv.classList.remove('opacity-100');

                // Auto-restart if it wasn't a manual stop
                if (!wasStoppedManually) {
                    console.log("Recognition stopped unexpectedly, restarting...");
                    recognition.start();
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                statusDiv.textContent = `Error: ${event.error}`;
                if (event.error === 'no-speech' || event.error === 'network') {
                    // Don't treat these as fatal errors for auto-restart logic
                } else {
                    wasStoppedManually = true; // Prevent restart on critical errors
                }
            };

            recognition.onresult = (event) => {
                interimTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                
                // Use stored cursor position to insert text
                const selection = window.getSelection();
                if(lastCursorPosition && selection.rangeCount > 0) {
                    selection.removeAllRanges();
                    selection.addRange(lastCursorPosition);
                } else {
                    // Fallback: move cursor to the end if no position is stored
                     const range = document.createRange();
                     range.selectNodeContents(dictationBox);
                     range.collapse(false);
                     selection.removeAllRanges();
                     selection.addRange(range);
                }

                // Insert the new text. Using execCommand is more reliable for undo/redo
                document.execCommand('insertText', false, finalTranscript + interimTranscript);
                finalTranscript = '';
            };

            // --- UI Button Event Listeners ---
            startBtn.addEventListener('click', () => {
                saveState();
                finalTranscript = ''; // Reset transcript
                recognition.start();
            });

            stopBtn.addEventListener('click', () => {
                wasStoppedManually = true;
                recognition.stop();
            });

            clearBtn.addEventListener('click', () => {
                saveState();
                dictationBox.innerHTML = '';
            });

            undoBtn.addEventListener('click', () => {
                if (history.length > 0) {
                    dictationBox.innerHTML = history.pop();
                }
                if (history.length === 0) {
                    undoBtn.disabled = true;
                }
            });

            // --- Local Storage for Entries ---
            const STORAGE_KEY = 'voiceDictationEntries';

            const loadEntries = () => {
                const entries = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                entriesDropdown.innerHTML = '<option selected>Load a saved entry...</option>';
                entries.forEach((entry, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    // Create a short preview for the dropdown
                    const preview = entry.text.substring(0, 40).replace(/<[^>]+>/g, '') + (entry.text.length > 40 ? '...' : '');
                    option.textContent = `${new Date(entry.date).toLocaleString()} - ${preview}`;
                    entriesDropdown.appendChild(option);
                });
            };

            saveBtn.addEventListener('click', () => {
                const text = dictationBox.innerHTML.trim();
                if (text) {
                    saveState();
                    const entries = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                    entries.unshift({ text, date: new Date().toISOString() });
                     if (entries.length > 50) { // Limit number of saved entries
                        entries.pop();
                    }
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(entries));
                    loadEntries();
                    alert('Entry saved!');
                } else {
                    alert('Nothing to save.');
                }
            });

            entriesDropdown.addEventListener('change', (e) => {
                const entries = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                const selectedIndex = e.target.value;
                if (selectedIndex !== '' && entries[selectedIndex]) {
                    saveState();
                    dictationBox.innerHTML = entries[selectedIndex].text;
                }
            });
            
            // --- Context Menu Logic ---
            dictationBox.addEventListener('mouseup', (e) => {
                const selection = window.getSelection();
                if (selection && !selection.isCollapsed) {
                    currentSelectionRange = selection.getRangeAt(0).cloneRange();
                    const rect = currentSelectionRange.getBoundingClientRect();
                    contextMenu.style.left = `${e.pageX}px`;
                    contextMenu.style.top = `${e.pageY - 50}px`; // position above selection
                    contextMenu.classList.remove('hidden');
                } else {
                    contextMenu.classList.add('hidden');
                }
            });
            
            // Hide context menu if clicking elsewhere
            document.addEventListener('mousedown', (e) => {
                if (!contextMenu.contains(e.target) && !dictationBox.contains(e.target)) {
                    contextMenu.classList.add('hidden');
                }
            });

            // --- Context Menu Actions ---
            const restoreSelection = () => {
                 if (currentSelectionRange) {
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(currentSelectionRange);
                }
            }

            copyAction.addEventListener('click', () => {
                restoreSelection();
                document.execCommand('copy');
                contextMenu.classList.add('hidden');
            });

            deleteAction.addEventListener('click', () => {
                saveState();
                restoreSelection();
                document.execCommand('delete', false, null);
                contextMenu.classList.add('hidden');
            });
            
            redictateAction.addEventListener('click', () => {
                saveState();
                restoreSelection();
                // We'll replace the content with a placeholder, start dictation,
                // and the result handler will replace the placeholder.
                // This is a simplified approach. For this app, we will just delete and start dictating.
                document.execCommand('delete', false, null);
                contextMenu.classList.add('hidden');
                startBtn.click();
            });
            
            reviseAction.addEventListener('click', () => {
                restoreSelection();
                const selectedText = window.getSelection().toString();
                reviseInput.value = selectedText;
                reviseModal.classList.remove('hidden');
                reviseInput.focus();
                reviseInput.select();
                contextMenu.classList.add('hidden');
            });
            
            // --- Revise Modal Logic ---
            submitReviseBtn.addEventListener('click', () => {
                saveState();
                restoreSelection();
                if (reviseInput.value.trim()) {
                    document.execCommand('insertText', false, reviseInput.value);
                }
                reviseModal.classList.add('hidden');
            });

            cancelReviseBtn.addEventListener('click', () => {
                reviseModal.classList.add('hidden');
            });

            // --- Initial Load ---
            loadEntries();
            undoBtn.disabled = true;
        });
    </script>
</body>
</html>
